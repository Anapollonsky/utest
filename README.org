* Header
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER: \usepackage{etoolbox}
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\fontsize{12}{12}\selectfont}
#+LaTeX_CLASS: code-article 
#+HTML_HEAD: "<style type="text/css">.org-src-container{ background-color: #181830; color: #DDDDFF; font-size: 130%} </style>"
#+OPTIONS: title:nil ^:nil
#+BIND: org-latex-title-command ""
* GUT Documentation V2
** About
GUT is a testing platform, particularly well suited for testing inferior hardware over a telnet or ssh connection. GUT provides a flexible framework that allows for easy expansion by the user of existing functionality, while providing a simple, YAML-formatted syntax for running tests.

GUT has a simple structure. Tests are written in YAML format and are passed to the program. Tests specify a sequence, in which each member consists of an /interface/ and a set of corresponding /command functions/. An /interface/ is a class that specifies how connection and subsequent communication is performed. The associated /command functions/ are actions that can be performed for every entry in the sequence. They range from something as simple as setting a connection variable (Setting the username used during login, for example), to actually sending data over the interface or parsing the response. /Command functions/ are flexible, simple to write, and are always executed in a deterministic order.

The flexible interface abstraction provides GUT with the flexibility to be used to develop sophisticated, top-level tests for various systems.

** Usage
This section will give a brief introduction to writing proper YAML files for GUT with the default YAML parser.

*** Overview
YAML is used as the language of choice for GUT. It was chosen over XML due to the relative conciseness of the syntax, over JSON due to the support of multi-line strings, and over a custom solution due to the desire to use a standardized format. Below is a very simple example of a test.
#+BEGIN_SRC yaml
global:
  username: lucent
  password: notpassword
  interface: telnet

cmd:
  send: pwd
  wait_after_send: .5
  log: logs/test2log
  print_response:
#+END_SRC

Note that YAML is, like python itself, reliant on whitespace to designate structure. There are two blocks in the above snippet: a =global= block, and a =cmd= block. Top-level blocks such as these are parsed sequentially -- the =cmd= block is parsed only after GUT is finished with =global=. There are only three types of top-level blocks supported: =global=, =cmd= and =include=. An =include= block is used to include YAML code from another file into the current test. The =global= block specifies global settings that will be merged with every subsequent =cmd= block, until another =global= block overwrites the global settings. As such, the snippet above is equivalent to the following:

#+BEGIN_SRC yaml
cmd:
  username: lucent
  password: notpassword
  interface: telnet
  send: pwd
  wait_after_send: .5
  log: logs/test2log
  print_response:
#+END_SRC

The =cmd= block is responsible for sending data over an interface and performing analysis on the results. Each =cmd= block is a dictionary that maps "command functions" to their arguments. In the example above, =username= is a function with the argument "lucent", =wait_after_send= is a function with the argument 0.5, and =print_response= is a function with no argument. The order in which these functions appear in a block has no effect on how the block is executed; instead, these functions are run in an order determined by the /priority/ of the function. The priority of a function is a hardcoded numerical value assigned to each function; the higher the priority, the lower the priority-number, the earlier the function will be run in each block. 

In addition to the commands above, there are some commands functions which are dynamically included due to the command-line arguments. For example, in the block above, you see that there is no specification of the address of the target. This is because the GUT command-line argument =--address= was used to set the address. This value is used as the default, but it can be overwritten by manually inserting an =address: localhost= entry or similar in a block. Similarly, certain interfaces implicitly include their own commands into each command. For a telnet frame, there are two commands which are always inserted and hidden: =connect= and =capture=. The =connect= command function has a priority such that it is run after all connection parameters, such as "interface", "username" and "password", have been set. It opens a connection to the desired target, or returns an existing one if a previous command had already opened one. The =capture= command, on the other hand, is used to capture any responses from the target.

With these modifications (and if the command was run with =--address localhost=), the block above is also thus equivalent to:

#+BEGIN_SRC yaml
cmd:
  username: lucent
  password: notpassword
  interface: telnet
  send: pwd
  wait_after_send: .5
  log: logs/test2log
  print_response:
  connect:
  capture:
  address: localhost
#+END_SRC

Here's what GUT does, given the block above:
+ Set the frame attribute =username= to "lucent"
+ Set the frame attribute =password= to "notpassword"
+ Set the frame attribute =interface= to "sh"
+ Set the frame attribute =address= to "localhost"
+ Open a connection to the target, which uses frame attributes =username=, =password=, =interface= and =address=.
+ Send the text "pwd" down the connection to the target.
+ Wait for 0.5 seconds.
+ Capture the response.
+ Print the response.
+ Append the response to logfile "log/test2log".

This is all well and good, but what if we want to run functions that require a more complicated input than a string or a number? What about multiple arguments to functions? How can this be handled? The GUT parser handles multiple arguments by accepting a /dictionary/ (or /map/) of arguments. Here's an example:
#+BEGIN_SRC yaml
cmd:
  expect:
    array: [teststring, (?)error]
    regex: True
#+END_SRC
=expect= above is a function that accepts two arguments, =array= and =regex=, that match the parameters in the function definition. The expect definition also defines a default value for the =regex= argument, making it optional. This also leads into a demonstration of how the more compact argument passing shown previously works: In the event that a single argument is sufficient to run the command function, that argument can be passed directly to the function name. Thus, if we were willing to sacrifice regex support, the command could be rewritten as:
#+BEGIN_SRC yaml
cmd:
  expect: [teststring, (?)error]
#+END_SRC
This "optimization" makes it easier to write concise tests.

*** Complicated Example
Below is an example of a more complicated test, showing the flexibility of GUT.
#+BEGIN_SRC yaml
global:
  interface: bci
  username: lucent
  password: password
  reject: "error"
  send: /oam/hwVersion

cmd:
  address: 135.112.98.16
  store_regex:
    - "FPGA Version: (.*), CPLD Version: (.{3})"
    - "HwVersion: (.*) HwRef" 

cmd:
  address: 135.112.98.30
  check_regex:
    - "FPGA Version: (.*), CPLD Version: (.{3})"
    - "HwVersion: (.*) HwRef"  

global:
  interface: ard546
  address: 135.112.98.30  
  
cmd:
  send: |
    [
    MESSAGE: TYPE=SET 
    TRANSACTION: ID=1 
    ALDDEVDATA: INDEX=1 ALDSUB=1 FIELDNUM=0X21 FIELDLENGTH=6 FIELDDATA=0X44454647,0X4849000
    ]
  print_response:
  expect_regex:
    - (?i)error
    - ID
#+END_SRC
What is this test doing? The first =global= block specifies several options to be used for the subsequent BCI commands: =interface=, =username= and =password=. It also specifies a =send= function, which means that for every subsequent =cmd= block, the message being sent will stay the same. Lastly, due to the =reject= command function, if, in the subsequent messages, the substring "error" occurs in the responses, GUT will throw an error.

Next are two =cmd= blocks. They both specify different board addresses, and one specifies =store_regex=, and the other specifies =check_regex=. The =store_regex= scans the response from the target for an expression matching the regex, and stores multiple values which match the sections within parentheses. The =check_regex= function performs the same match, except that instead of storing it, it compares with existing stored values. Thus, this test checks whether the captured FPGA version, CPLD Version and HwVersion are identical for both targets, without requiring knowing in advance of what those versions are. In order to use these commands (and, indeed, understand the terminology), it is strongly recommended that the user be familiar with regular expressions. 

The next =global= block specifies a new set of global settings that completely overwrites those introduced by the previous =global= block. The subsequent commands are now sent over the ard546 interface to the target at 135.112.98.30. Note that neither =username= or =password= are specified; they are unneeded for the ard546 interface.

Lastly, the ard546 =cmd= block transmits a multi-line string (note the pipe that, in YAML syntax, specifies that a multi-line string is being stored), checks to ensure that the regexes =(?i)error= (case-insensitive "error") and =ID= are match the response, and finally prints the response. Here's the response under maximum verbosity:
#+BEGIN_SRC 
========================== Beginning Iteration 1 of 1... ===========================
                   _______ Entering "./tests/test3.yaml" ________                   
                   _____________ Sending bci frame ______________                   
Connected to bci at 135.112.98.16
Running send
Running reject
Running store_regex
  > Regex "FPGA Version: (.*), CPLD Version: (.{3})" captured: "('0x360b', '0x2')"
  > Regex "HwVersion: (.*) HwRef" captured: "('P1',)"
                   _____________ Sending bci frame ______________                   
Connected to bci at 135.112.98.30
Running send
Running reject
Running check_regex
  > Regex "FPGA Version: (.*), CPLD Version: (.{3})" matches: "('0x360b', '0x2')"
  > Regex "HwVersion: (.*) HwRef" matches: "('P1',)"
                   ____________ Sending ard546 frame ____________                   
Connected to ard546 at 135.112.98.30
Running send
Running expect_regex
  > Captured in response: ID
  > Captured in response: (?i)error
Running print_response
  > [
MESSAGE: TYPE=SETRESPONSE
TRANSACTION: ID=1
ERRORIND: ATTR=ALDDEVDATA DATAFIELD=ALDSUB ERROR="ACTION NOT ALLOWED" INFO="CANNOT S
ET DATA"                                                                           
ERRORIND: ATTR=ALDDEVDATA DATAFIELD=FIELDNUM ERROR="ACTION NOT ALLOWED" INFO="CANNOT
 SET DATA"                                                                         
ERRORIND: ATTR=ALDDEVDATA DATAFIELD=FIELDLENGTH ERROR="ACTION NOT ALLOWED" INFO="CAN
NOT SET DATA"                                                                      
ERRORIND: ATTR=ALDDEVDATA DATAFIELD=FIELDDATA ERROR="ACTION NOT ALLOWED" INFO="CANNO
T SET DATA"                                                                        
]
                   ________ Leaving "./tests/test3.yaml" ________                   
============================== Iteration 1 Completed ===============================

#+END_SRC


** Development
*** Overview
GUT is composed of several modules:
+ The main, or *gut.py*, is responsible for controlling program flow. 
+ The parser, *yaml_parser.py* by default, is responsible for reading a YAML file and converting it to a workable data structure.
+ Conman, in *conman.py*, is a singleton class that is used to transfer information between different parts of the program, handle messaging, and manage connections to different interfaces and addresses.
+ Interfaces are classes, descended from the class "Frame", that define a name, connection mechanism, command functions and helper functions to allow the tester to interact with another object in a useful way. 

*** Adding a command function
As referred to here, a /command function/ is a command that can be run inside a GUT command-block. GUT performs almost everything through these functions, for the purpose of architectural simplicity.

Command functions are defined in interface classes. Very broad functions that could be useful in any interface can be written in the /Frame/ class directly, to make them available everywhere. More targeted functions should be written wherever appropriate so that interfaces that have no need of the functions don't inherit it. 

Below is sample code used for the =log= function. A =@command= decorator specifies the priority, hooks and whether the function is quiet. Priority is required, as GUT needs to know how to prioritize different functions; the other two have sane defaults. The next line is the function definition itself. The first argument of every function must be used to pass the frame object itself, and subsequent arguments can be any other python object that can be interpreted by the parser. The passing of the frame object is handled by GUT itself, and every other argument is reliant on the testfile.

#+BEGIN_SRC python
      @command(priority = 100, hooks = [hook_show_args])
      def log(self, filename):
          """Low-priority function to log the sent and received messages to a given file."""
          try:
              infile = open(filename, 'a')
          except IOError:
              self.conman.ferror("Failed to open file " + filename + " for logging.")
          infile.write(self._send + "\n\n" + self._response + "\n\n")
          infile.close()
#+END_SRC

Several things to note:
+ Perhaps confusingly, "high" priority corresponds to a low value the "priority" function attribute. A priority of 0 will be run very early in the process, whereas 100 will be run very late.
+ Command functions are very flexible, and there are no restrictions on what code you put in them. Here, log is performing I/O operations. It's inefficient, because every single frame will be opening and closing the file, but it shouldn't be a bottlenecking issue.

*** Adding an interface
Interfaces are objects that define a connection and how to perform certain operations on it -- how to connect, how to send data, how to receive data -- and are used to allow for connections to be more flexible. All interfaces are stored under */interfaces*, and they all inherit from /Frame/ in *frame.py*. This section will analyze an existing interface under *telnet_frame.py*, which should make it trivial to write your own.

The header of the class includes any required objects and defines the class as inheriting from the /Interactive_Frame/ class. The /Interactive_Frame/ class itself inherits from /Frame/ and defines useful functions to allow the user to interact directly with the target, instead of relying on built-in functions to format and send any messages. 

The header also defines a class =interfacename=, which is the string that will be used by the rest of the program to differentiate between different interfaces. As such, the interfacename should be distinct from that of every other interface. Note that this particular interface uses telnetlib -- no code outside of the interfaces should know of the details of how the communication protocol works.
#+BEGIN_SRC python
import time
import telnetlib
import socket
from interfaces.frame import Interactive_Frame
from decorators import command

class telnet_Frame(Interactive_Frame):
    interfacename = "telnet"    
#+END_SRC

The /establishConnection/ method is used to establish a ready-to-use connection. The interface returns a connection object that will be stored in conman, and used whenever another command wants to use an interface with the same arguments. This function is required for all interfaces.
#+BEGIN_SRC python
    def establish_connection(self, address, username, password):
        """ Connection procedure for remote shell."""
        try:
            con = telnetlib.Telnet(address, 23, 10)
        except socket.timeout:
            return None
        con.expect(['ogin'.encode('ascii')])
        con.write(username.encode('ascii') + b"\n")
        con.expect(['assword'.encode('ascii')])
        con.write(password.encode('ascii') + b"\n")
        time.sleep(.2)
        return con
#+END_SRC

The /send_frame/ method accepts no arguments apart from /self/, and is responsible for sending the contents of =self.send["content"]= down the connection. This function is required for interfaces inheriting from /Interactive_Frame/.
#+BEGIN_SRC python
    def send_frame(self):
        """Transmit a frame object's content to intended recipient."""
        self._connection.write(self._send.encode('ascii') + b"\n")
#+END_SRC

The /expect_message/ method accepts two arguments: an array, and a timer. The array is a list of regexes which are to be looked for, and the timer specifies when the expect operation times out. This method is needed for the command functions "expect" to work, and allows "expect" itself to remain unchanged by different interfaces and connection backends. This method returns a tuple either =(None, True)= in the event of a timeout, or =(str, False)= in the event of a capture, where =str= is all the text leading up to the captured string, inclusive. This function is required for interfaces inheriting from /Interactive_Frame/.
#+BEGIN_SRC python
    def expect_message(self, array, timer):
        """Wait for a message from an array, return either a capture or a timeout."""        
        results = self._connection.expect([x.encode('ascii') for x in array], timer)
        if results[0] == -1:
            return (None, True) # Return no capture, timeout
        else:
            return (results[2].decode('ascii'), False) # Return capture, no timeout
#+END_SRC

The /capture_message/ method is used in lieu of the /expect_message/ method for capturing text in the event that we don't know what string to expect. The method below simply waits a short period of time, and then returns all text that arrived during that period. This function is required for interfaces inheriting from /Interactive_Frame/.
#+BEGIN_SRC python
    def capture_message(self):
        """Try to capture text without an "expect" clause."""
        time.sleep(.4)
        return self._connection.read_very_eager().decode('ascii')
#+END_SRC

The command functions below, /username/, /password/ and /address/, are used exclusively to set the attributes that will be read during connection. Note the underscore before the attribute; this is necessary to differentiate the attribute variable from the function, which is itself an attribute of each frame.
#+BEGIN_SRC python
################################################################################
#################### Command functions
    @command(0, quiet=True)
    def username(self, username):
        """Used to set the connection username, if any."""
        self._username = username        

    @command(0, quiet=True)
    def password(self, password):
        """Used to set the connection password, if any."""
        self._password = password

    @command(0, quiet=True)
    def address(self, address):
        """Used to set the connection address."""
        self._address = address

#+END_SRC
* scpi

** MXA
*** Working:
Center freq: :SENS:FREQ:CENT 1.94 GHz
Make marker: CALC:MARK1:MODE POS
Set marker frequency: CALC:MARK1:X 1.93 GHz

*** Not Working:
Read marker value: CALC:MARK2:Y?
Calculate Peak: :CALC:DATA1:PEAK?


